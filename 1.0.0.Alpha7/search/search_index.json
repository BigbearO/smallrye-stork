{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview SmallRye Stork 1.0.0.Alpha7 is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That's where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment The problem In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end. The solution Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies. What if the infrastructure provides such a feature? Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don't need that flexibility, just use the infrastructure layer.","title":"Overview"},{"location":"#overview","text":"SmallRye Stork 1.0.0.Alpha7 is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That's where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment","title":"Overview"},{"location":"#the-problem","text":"In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end.","title":"The problem"},{"location":"#the-solution","text":"Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies.","title":"The solution"},{"location":"#what-if-the-infrastructure-provides-such-a-feature","text":"Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don't need that flexibility, just use the infrastructure layer.","title":"What if the infrastructure provides such a feature?"},{"location":"concepts/","text":"Concepts This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly. Process overview When using the programmatic API of Stork, you: Retrieves the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieves the Service you want to use. Each Service is associated with a name. Retrieves the ServiceInstance which will provides the metadata to access the actual service. Behind the scene, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni . Stork io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicate how Stork can select the most appropriate instance. Service A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured. Service Instance The io.smallrye.stork.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; import java.util.List ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getServiceInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; import java.util.List ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectServiceInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } } Service Discovery The io.smallrye.stork.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the ServiceDiscovery implementation must be non-blocking. Load Balancer The io.smallrye.stork.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking.","title":"Concepts"},{"location":"concepts/#concepts","text":"This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly.","title":"Concepts"},{"location":"concepts/#process-overview","text":"When using the programmatic API of Stork, you: Retrieves the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieves the Service you want to use. Each Service is associated with a name. Retrieves the ServiceInstance which will provides the metadata to access the actual service. Behind the scene, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni .","title":"Process overview"},{"location":"concepts/#stork","text":"io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicate how Stork can select the most appropriate instance.","title":"Stork"},{"location":"concepts/#service","text":"A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured.","title":"Service"},{"location":"concepts/#service-instance","text":"The io.smallrye.stork.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; import java.util.List ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getServiceInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; import java.util.List ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectServiceInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } }","title":"Service Instance"},{"location":"concepts/#service-discovery","text":"The io.smallrye.stork.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the ServiceDiscovery implementation must be non-blocking.","title":"Service Discovery"},{"location":"concepts/#load-balancer","text":"The io.smallrye.stork.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking.","title":"Load Balancer"},{"location":"consul/","text":"Consul Service Discovery Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It's often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery. Dependency First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-consul </artifactId> <version> 1.0.0.Alpha7 </version> </dependency> Configuration For each service expected to be registered in Consul, configure the lookup: stork.my-service.service-discovery = consul stork.my-service.service-discovery.consul-host = localhost stork.my-service.service-discovery.consul-port = 8500 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description consul-host No localhost The Consul host consul-port No 8500 The Consul port use-health-checks No false Whether to use health check","title":"Consul"},{"location":"consul/#consul-service-discovery","text":"Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It's often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery.","title":"Consul Service Discovery"},{"location":"consul/#dependency","text":"First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-consul </artifactId> <version> 1.0.0.Alpha7 </version> </dependency>","title":"Dependency"},{"location":"consul/#configuration","text":"For each service expected to be registered in Consul, configure the lookup: stork.my-service.service-discovery = consul stork.my-service.service-discovery.consul-host = localhost stork.my-service.service-discovery.consul-port = 8500 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description consul-host No localhost The Consul host consul-port No 8500 The Consul port use-health-checks No false Whether to use health check","title":"Configuration"},{"location":"kubernetes/","text":"Kubernetes Service Discovery Kubernetes provides has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery. Dependency First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-kubernetes </artifactId> <version> 1.0.0.Alpha7 </version> </dependency> Configuration For each service expected to be exposed as Kubernetes Service , configure the lookup: stork.my-service.service-discovery = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example). Instead of use the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspect the service and retrieve the list of pods providing the service. Then, it can select the instance. Supported attributes are the following: Attribute Mandatory Default Value Description k8s-host No master url The Kubernetes API host k8s-namespace No all The namespace of the service","title":"Kubernetes"},{"location":"kubernetes/#kubernetes-service-discovery","text":"Kubernetes provides has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery.","title":"Kubernetes Service Discovery"},{"location":"kubernetes/#dependency","text":"First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-kubernetes </artifactId> <version> 1.0.0.Alpha7 </version> </dependency>","title":"Dependency"},{"location":"kubernetes/#configuration","text":"For each service expected to be exposed as Kubernetes Service , configure the lookup: stork.my-service.service-discovery = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example). Instead of use the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspect the service and retrieve the list of pods providing the service. Then, it can select the instance. Supported attributes are the following: Attribute Mandatory Default Value Description k8s-host No master url The Kubernetes API host k8s-namespace No all The namespace of the service","title":"Configuration"}]}